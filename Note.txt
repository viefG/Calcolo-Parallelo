ES1:
    Nell'esercizio 1 non ho avuto particolare difficoltà, nella versione v2 (quella in cui 'C' è uno scalare) ho sbagliato
    facendo all'interno del parallel c[i] = a[i] + b[i]; invece di c[i] += a[i] + b[i];

ES5:
    Nell'esercizio 5 le difficoltà sono state nel gestire l'inizio e la fine delle righe, inoltre non funziona se N (numero delle righe
    e coonne della matrice) e np (thread) N/np non da resto 0, nel caso dia resto 1 crea problemi.

ES6:
    Nell'esercizio 6_v2 (la seconda versione, quella in cui il risultato è uno scalare) ho avuto difficoltà a moltiplicare la 
    matrice con lo scalare alpha, ho dovuto modificare più volte il codice perchè il risultato non era corretto.

ES7
    Nell'esercizio 7 ho avuto difficoltà a implementare la logia in generale, ci ho messo più tempo del dovuto, mi sono reso conto
    dopo quale minuti di dover prendere il numero del thread (id) cosa che dovrebbe essere scontata.

ES8
    Nell'esercizio 8 mi sono confuso, nel ciclo for esterno (quello che gestisce le colonne) invece di dare come limite
    end ho scritto size e ci ho messo tantissimo per accorgermene

ES10
    Nell'esercizio 10 mi sono confuso, inizialmente ho fatto in questo modo:
      #pragma omp parallel num_threads(np) reduction (+:somma)
    {   
        for (int i=1;i<N;i+=2){
            for (int j=0;j<M;j++){
                printf("Somma temporanea: %d del thread %d\n",somma,omp_get_thread_num());
                somma+=A[i][j];
            }
        }
    }

    Facendo ciò mi sono reso conto dall'out che effettivamente fa la somma delle righe dispari ma lo fa per ogni thread,
    poi ho risolto facendolo con il for (#pragma omp parallel for) in modo che ogni thread si impegnasse a prendere
    dei valori di i.

    ES11
        DISASTROSO...

    ES13
        Nell'esercizio 13 avevo implementato la ricerca del minimo senza usare reduction, il progamma funzionare ma chat mi ha fatto
        notare che i thread potrebbero sovrascriverla contemporaneamente  e quindi anche se poco probabile qualche volta potrebbe
        non funzionare, utilizzando reduction si previene questo problema.

    ES14
        L'esercizio 14 è molto simile all'11 e per questa ragione non è stato semplice, l'ho risolto ma sono andato per tentativi,
        mi perdo facilmente nella logica

    ES16
        Sinceramente non ho capito perfettamente la tracci, è della stessa tipologia dell 11 e del 14
    